<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PLUMED: PLUMED Masterclass 22.10: Hamiltonian replica exchange with PLUMED and GROMACS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script>
   var redpath = "";
   
   function showPath(eg,name) {
     var i; var y = document.getElementsByName(redpath);
     for (i=0; i < y.length; i++ ) { y[i].style.color="black"; }
     var x = document.getElementsByName(name); redpath=name;
     for (i = 0; i < x.length; i++) { x[i].style.color="red"; }
     var valid="value_details_".concat(eg);
     var valueField = document.getElementById(valid);
     var dataField = document.getElementById(name);
     valueField.innerHTML = dataField.innerHTML;
   }
   function swapInput(name) {
     var btn = document.getElementById(name + "_button");
     var mydiv = document.getElementById("input_" + name);
     if( btn.textContent=="expand shortcuts" ) {
         btn.textContent = "contract shortcuts";
         var dataField = document.getElementById(name + "long");
         mydiv.innerHTML = dataField.innerHTML;
     } else if( btn.textContent=="contract shortcuts" ) {
         btn.textContent = "expand shortcuts";
         var dataField = document.getElementById(name + "short");
         mydiv.innerHTML = dataField.innerHTML;
     }
   }
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../developer-doc/html/index.html"> <img src="user-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.9.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('masterclass-22-10.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">PLUMED Masterclass 22.10: Hamiltonian replica exchange with PLUMED and GROMACS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Giovanni Bussi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>June 21, 2022</dd></dl>
<h1><a class="anchor" id="masterclass-22-10-aims"></a>
Aims</h1>
<p>In this Masterclass, we will discuss how to run Hamiltonian replica exchange using PLUMED and GROMACS. We will also understand how to analyze the resulting trajectories. It is highly recommended to follow <a class="el" href="masterclass-21-5.html">PLUMED Masterclass 21.5: Simulations with multiple replicas</a> in advance.</p>
<h1><a class="anchor" id="masterclass-22-10-lo"></a>
Objectives</h1>
<p>Once you have completed this Masterclass you will be able to:</p>
<ul>
<li>Use PLUMED to manipulate GROMACS topologies and prepare a solute tempering simulation.</li>
<li>Use PLUMED and GROMACS to run replica-exchange simulations with multiple topologies.</li>
<li>Use WHAM to combine multiple simulations performed with different topologies and/or bias potentials.</li>
</ul>
<h1><a class="anchor" id="masterclass-22-10-install"></a>
Setting up PLUMED</h1>
<p>For this masterclass you will need versions of PLUMED and GROMACS that are compiled using the MPI library. In order to obtain the correct versions, please follow the instructions at <a href="https://github.com/plumed/masterclass-2022">this link</a>.</p>
<h1><a class="anchor" id="masterclass-22-10-resources"></a>
Resources</h1>
<p>The data needed to execute the exercises of this Masterclass can be found on <a href="https://github.com/plumed/masterclass-22-10">GitHub</a>. You can clone this repository locally on your machine using the following command:</p>
<pre class="fragment">git clone https://github.com/plumed/masterclass-22-10.git
</pre><dl class="section note"><dt>Note</dt><dd>All the exercises were tested with PLUMED version 2.8.0 and GROMACS 2020.6</dd></dl>
<p>Additional documentation about the replica exchange implementation discussed in this Masterclass can be found at this page: <a class="el" href="hrex.html">Using Hamiltonian replica exchange with GROMACS</a> .</p>
<h1><a class="anchor" id="masterclass-22-10-ex"></a>
Exercises</h1>
<p>Throughout this Masterclass we will run simulations of <b>alanine dipeptide in water</b> using GROMACS and PLUMED. Whereas this system is too simple to be considered a proper benchmark for enhanced sampling methods, it is complex enough to be used in learning them. This Masterclass regards a specific implementation of Hamiltonian replica exchange that is only available when combining GROMACS and PLUMED.</p>
<p>Notice that simulations might take up to a couple of hours, depending on the hardware you have access to. The version of GROMACS that we provide on our conda channel is not optimized. Compiling GROMACS directly on your machine might lead to much better performance. In addition, using a GPU will also make your simulations significantly faster.</p>
<h2><a class="anchor" id="masterclass-22-10-intr"></a>
Introduction to Hamiltonian replica exchange</h2>
<p>In <a class="el" href="masterclass-21-5.html">PLUMED Masterclass 21.5: Simulations with multiple replicas</a> we have learned how to run replica-exchange simulations where each replica was possibly feeling different biasing forces. A typical example is umbrella sampling with replica exchange, where each replica has a restraint located in a different position. Another example is bias-exchange metadynamics, where each replica is biased along a different collective variable. We have also seen parallel-tempering metadynamics, where replicas are kept at a different temperature and, at the same time, keep track of different history-dependent potentials. All these examples are a form of Hamiltonian replica exchange, since different replicas are subject to different potential energy functions, and thus different Hamiltonians.</p>
<p>In this masterclass we will consider a conceptually similar but technically different implementation of Hamiltonian replica exchange. Here, the different replicas will be simulated using different force field parameters. For most of the exercise, we will thus use an empty <code>plumed.dat</code> file (no bias added!). You will however need to include this file to ensure PLUMED can be enabled. We will also spend some time in learning how to edit the GROMACS topologies, so as to generate the modified force fields.</p>
<p>In order to use multiple-replica methods, you should run your simulation using MPI. This can be done prefixing your command with <code>mpiexec -np N --oversubscribe</code>, where <code>N</code> is the number of processes that you want to use and the <code>--oversubscribe</code> option is an OpenMPI option that is required to use more processes than the number of available processors. This is typically suboptimal, but we will need it in our lectures to run, e.g., simulations with 16 replicas even if we have a computer with 4 cores.</p>
<p>In brief, to run a GROMACS simulation where the individual replicas are in directories names <code>dir0</code>, <code>dir1</code>, etc and the (possibly empty) <code>plumed.dat</code> file is in the parent directory you will need a command such as </p><div class="fragment"><div class="line">mpiexec -np 16 --oversubscribe gmx_mpi mdrun -multidir dir? dir?? -plumed ../plumed.dat -replex 200 -hrex</div>
</div><!-- fragment --><p>The option <code>-replex 200</code> enables replica exchange and ensures exchanges are attempted every 200 steps. The option <code>-hrex</code> is specific for the implemenation discussed in this Masterclass, and informs GROMACS and PLUMED that there might be different force fields used in different replicas.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you forget the <code>-hrex</code> flag, no error will be issued, but the acceptance for exchanges will be incorrectly calculated.</dd></dl>
<p>If you have random crashes on MacOS, try to set this environemnt variable: </p><pre class="fragment">export OMPI_MCA_btl="self,tcp"
</pre><p>In the root directory of this Masterclass you will find a <code>conf.gro</code> file, that can be used as a starting configuration for your simulations, a <code>topol.top</code> file, which contains the topology information, and a <code>grompp.mdp</code> file with reasonable simulation parameters. You have also a <code>conf.pdb</code> file, that is basically the <code>conf.gro</code> file converted to PDB format, and can be used for the <a class="el" href="_m_o_l_i_n_f_o.html">MOLINFO</a> keyword so as to facilitate atom selections in analysis.</p>
<h2><a class="anchor" id="masterclass-22-10-ex-1a"></a>
Exercise 1a: Test with different temperatures</h2>
<p>Before swithing to solute tempering, we will play a bit with parallel tempering. Parallel tempering simulations require the highest replica to be hot enough for important energy barriers to be crossed in the simulation. We will first estimate how much we should raise the temperature so as to see forward and backward transitions between the two metastable states of our system.</p>
<p>To do so:</p><ul>
<li>Prepare an array of simulations, with temperatures equal to 300, 400, 500, 600, 700, 800, 900, 1000</li>
<li>Run each of them for 1 ns and check at which temperature you have at least one transition from the initial basin to the other one and one backward transition</li>
</ul>
<p>These are serial simulations, so you can run them with this command: </p><div class="fragment"><div class="line"><span class="preprocessor"># first edit grompp.mdp setting the temperature (both solute and solvent groups!)</span></div>
<div class="line"><span class="preprocessor"># then create the topol.tpr file:</span></div>
<div class="line">gmx_mpi grompp</div>
<div class="line"><span class="preprocessor"># then run your simulation:</span></div>
<div class="line"><span class="preprocessor">gmx_mpi mdrun -nsteps 500000</span></div>
</div><!-- fragment --><p>though it is recommended to use a script to run your simulations.</p>
<p>To analyze the resulting trajectories you can use PLUMED <a class="el" href="driver.html">driver</a> </p><div class="fragment"><div class="line">plumed driver --ixtc traj_comp.xtc --plumed plumed.dat</div>
</div><!-- fragment --><p>with the following <code>plumed.dat</code> file: </p>
<div style="width: 90%; float:left" id="value_details_eg1"> Click on the labels of the actions for more information on what each action computes </div>
<div style="width: 10%; float:left"><img src="https://img.shields.io/badge/v2.9-failed-red.svg" alt="tested on v2.9" /></div><pre style="width: 97%;" class="fragment">
<a href="https://www.plumed.org/doc-v2.9/user-doc/html/_m_o_l_i_n_f_o.html" style="color:green">MOLINFO</a> <div class="tooltip">STRUCTURE<div class="right"><b>compulsory keyword </b>
a file in pdb format containing a reference structure. <i></i></div></div>=conf.pdb <span style="display:none;" id="eg1"> You cannot view the components that are calculated by each action for this input file. Sorry </span>
<b name="eg1phi" onclick='showPath("eg1","eg1phi")'>phi: </b><a href="https://www.plumed.org/doc-v2.9/user-doc/html/_t_o_r_s_i_o_n.html" style="color:green">TORSION</a> <div class="tooltip">ATOMS<div class="right">the four atoms involved in the torsional angle <i></i></div></div>=@phi-2 <span style="display:none;" id="eg1phi"> You cannot view the components that are calculated by each action for this input file. Sorry </span>
<a href="https://www.plumed.org/doc-v2.9/user-doc/html/_p_r_i_n_t.html" style="color:green">PRINT</a> <div class="tooltip">ARG<div class="right">the input for this action is the scalar output from one or more other actions. <i></i></div></div>=<b name="eg1phi">phi</b> <div class="tooltip">FILE<div class="right">the name of the file on which to output these quantities <i></i></div></div>=COLVAR <span style="display:none;" id="eg1"> You cannot view the components that are calculated by each action for this input file. Sorry </span>
</pre>
<p>You can then plot the second column of the resulting <code>COLVAR</code> file and see if there is a transition from the first basin (phi in range (-3,-1)) to the second basin (phi in range (0.5,1.5)), and back. Answer the following question:</p><ul>
<li>How much should you increase the temperature to see a transition back-and-forth between the two basins?</li>
</ul>
<p>The result will depend on stochastic factors, but also on the length of the simulation. I recommend running a 1 ns long simulation (500000 steps), but you can try with a longer or shorter trajectory.</p>
<h2><a class="anchor" id="masterclass-22-10-ex-1b"></a>
Exercise 1b: Run a parallel tempering simulation</h2>
<p>Once you have identified this temperature, you can run a parallel tempering simulation. You will need a number of replicas to bridge from T=300 to the temperature you have identified. As a first guess, you can place them in a geometric series (that's the allocation that leads to uniform acceptance in a system with temperature-independent specific heat).</p>
<p>Let's say that you want to try with 16 replicas. You should create 16 directories named <code>dir0</code>, <code>dir1</code>, ... <code>dir15</code> and place a file named <code>topol.tpr</code> in each. Each <code>topol.tpr</code> files will be created setting a different temperature in the <code>grompp.mdp</code> file. We will not need PLUMED for this exercise, so the simulation can be run with a command like this one: </p><pre class="fragment">mpiexec -np 32 --oversubscribe gmx_mpi mdrun -multidir dir? dir?? -replex 200 -nsteps 500000
</pre><p>The <code>-replex</code> option tells to GROMACS how frequently exchanges should be attempted. The average acceptance will be reported at the end of the <code>md.log</code> file.</p>
<p>The hottest replica will display transitions between the two metastable states. Thanks to the exchanges, both states will be observed also in the replica that is kept as T=300K.</p>
<p>Now answer the following questions:</p><ul>
<li>How many replicas do you need to have an acceptance that is at least 30%? (the answer will depend on the maximum temperature you have chosen)</li>
<li>How much is the relative population of the two metastable states at T=300? Plot this population as a function of the temperature (you can just extract results from the different replicas).</li>
</ul>
<h2><a class="anchor" id="masterclass-22-10-ex-2a"></a>
Exercise 2a: Setting up scaled Hamiltonians</h2>
<p>In order to run Hamiltonian replica exchange simulations with multiple topologies, we will have first to learn how to generate the multiple topologies. Different tools could be used (including editing the <code>topol.top</code> file by hand!) but we will now learn how to use the <a class="el" href="partial_tempering.html">partial_tempering</a> tool available in PLUMED. This tool basically allows you to generate topologies where the energy of a subset of the atom have be scaled by a chosen factor. Remember that dividing the energy by a factor 2 is equivalent to multiplying the temperature by a factor 2.</p>
<p>Let's first have a look at the <code>topol.top</code> file. In this file there are a number of lines that look like <code>#include ...</code>, so that this file is not self-contained. The first thing that we have to do is to generate a self-contained topology file: </p><div class="fragment"><div class="line">gmx_mpi grompp -p topol.top -pp processed.top</div>
</div><!-- fragment --><p>Have a look at the resulting <code>processed.top</code> file with a text editor. This file does not contain only information about alanine dipeptide, but also about the generic force-field parameters. It is thus self-contained.</p>
<p>Then you should edit the <code>processed.top</code> file to indicate which atoms you want to scale. To do so you have to add an underscore (<code>_</code>) to the atom name of the selected atoms. For instance, this line: </p><div class="fragment"><div class="line">1         HC     1    ACE   HH31      1     0.1123      1.008   ; qtot 0.1123</div>
</div><!-- fragment --><p>should be modified to this line: </p><div class="fragment"><div class="line">1         HC_    1    ACE   HH31      1     0.1123      1.008   ; qtot 0.1123</div>
</div><!-- fragment --><p>To perform a solute tempering simulation, you should add the underscore to all the solute atoms (look in the <code>[ atoms ]</code> section). Once this is done you can use the following command: </p><div class="fragment"><div class="line">plumed partial_tempering 1.0 &lt; processed.top  &gt; scaled.top</div>
</div><!-- fragment --><p>This will scale the Hamiltonian of the selected atoms by a factor 1.0 (which means: no change!). Have a look at the resulting <code>scaled.top</code> file and find out what has changed. You can also try to apply two different scaling factors and check the difference: </p><div class="fragment"><div class="line">plumed partial_tempering 1.0 &lt; processed.top  &gt; scaled0.top</div>
<div class="line">plumed partial_tempering 0.5 &lt; processed.top  &gt; scaled1.top</div>
<div class="line">diff scaled0.top scaled1.top</div>
</div><!-- fragment --><h2><a class="anchor" id="masterclass-22-10-ex-2b"></a>
Exercise 2b: Sanity check on generated topologies</h2>
<p>Notice that these scaled topologies can be used to run GROMACS simulations. The <code>parial_tempering</code> script is far from perfect. We will now make some sanity check. To do these checks, we will either generate a new trajectory or simply take one of the trajectories that we generated in the previous exercise. We will then used a GROMACS tool named <code>rerun</code>, which allows recomputing the energy along a trajectory using a new topology.</p>
<p>First, create an energy file corresponding to the original topology: </p><div class="fragment"><div class="line"><span class="preprocessor"># it is better to do this in a separate directory and rename the</span></div>
<div class="line"><span class="preprocessor"># trajectory file, or gromacs will complain:</span></div>
<div class="line"><span class="preprocessor">gmx_mpi mdrun -rerun traj.xtc -s topol.tpr</span></div>
</div><!-- fragment --><p>The resulting <code>ener.edr</code> file can be converted to a text file with the <code>gmx_mpi energy</code> command.</p>
<p>Then, generate a new topology with scaling factor 1.0 and compute energies again: </p><div class="fragment"><div class="line">plumed partial_tempering 1.0 &lt; topol_selected.top &gt; topol_scaled.top</div>
<div class="line">gmx_mpi grompp -p topol_scaled.top -o topol_scaled.tpr</div>
<div class="line">gmx_mpi mdrun -rerun traj.xtc -s topol_scaled.tpr -e ener_scaled.edr</div>
</div><!-- fragment --><p>The resulting energies should be identical!</p>
<p>As a second check, generate a new topology where you scaled <em>all</em> atoms (make sure to also select water!) by a factor 0.5: </p><div class="fragment"><div class="line">plumed partial_tempering 0.5 &lt; topol_all_selected.top &gt; topol_all_scaled.top</div>
<div class="line">gmx_mpi grompp -p topol_all_scaled.top -o topol_all_scaled.tpr</div>
<div class="line">gmx_mpi mdrun -rerun traj.xtc -s topol_all_scaled.tpr -e ener_all_scaled.edr</div>
</div><!-- fragment --><p>This time, dihedral angles, LJ, and Coulomb energies should be multiplied by 0.5.</p>
<p>This is a very important check. The <code>partial_tempering</code> script is not compatible with some specific functional forms, e.g., CHARMM CMAP (search PLUMED mailing list for a fix). In case you are using an incompatible force field, you will find inconsistencies in these sanity checks. For the provided <code>topol.top</code> file, everything should work.</p>
<p><b> These tests are very important, please only proceed if you managed to pass them.</b></p>
<h2><a class="anchor" id="masterclass-22-10-ex-2c"></a>
Exercise 2c: Sanity check on replica-exchange implementation</h2>
<p>Another thing that we will have to check now is if acceptance is computed correctly. The code inserted in GROMACS to implement this calculation is non trivial and quite fragile. To do this check, you should run a short Hamiltonian replica exchange with two equivalent topology files. For instance, you can use the original <code>topol.tpr</code> file and the one that you obtained with scaling factor 1.0. Make sure that the two tpr files are using a different seed for randomizing the initial velocities or, even better, use two different <code>conf.gro</code> files to initialize the two simulations. For everything else, use the same settings you will use in production (ideally, same number of processes per replica, same GPU settings, etc).</p>
<p>Now run a short replica exchange simulation: </p><div class="fragment"><div class="line">mpiexec -np 2 --oversubscribe gmx_mpi mdrun -multidir dir0 dir1 -replex 200 -nsteps 10000 -hrex -plumed plumed.dat</div>
</div><!-- fragment --><p>As written above, <code>plumed.dat</code> can be just an empty file. Check the resulting acceptance. Since the Hamiltonians are identical, the acceptance <b>should be exactly 1.0</b>.</p>
<p>Notice that this might be expected to fail if you use a GPU.**</p>
<h2><a class="anchor" id="masterclass-22-10-ex-2d"></a>
Exercise 2d: Find minimum scaling factor needed to cross the barrier</h2>
<p>You are now able to generate tpr files where the energy of a subset of the atoms is scaled. We will do something similar to <a class="el" href="masterclass-22-10.html#masterclass-22-10-ex-1a">Exercise 1a: Test with different temperatures</a>, but playing with scaling factor instead of temperature. Make sure that you select all (and only) the atoms belonging to the solute (alanine dipeptide), so as to implement solute tempering. Try to run a set of 1 ns long simulations, with scaling factors decreasing (e.g., 1.0, 0.9, 0.8, etc). Now answer the following question:</p><ul>
<li>How much should you decrease the scaling factor to see transitions between the two metastable states in the first nanosecond?</li>
</ul>
<h2><a class="anchor" id="masterclass-22-10-ex-3"></a>
Exercise 3: Run Hamiltonian replica exchange simulations</h2>
<p>Now run a Hamiltonian replica exchange simulation with multiple replicas, bridging from lambda=1.0 to the minimun value identified in the previous point. I would suggest using a linear distribution in lambda rather than a geometric one, but you can experiment. Similarly to parallel tempering, we can for now just analyze the reference replica (at lambda=1.0).</p>
<p>Now answer the following questions:</p><ul>
<li>How many replicas (and which is the optimal distribution) you need to have an acceptance that is at least 30%? (the answer will depend on the minimum lambda you have chosen). Is this smaller or larger than the number of replicas that you used for <a class="el" href="masterclass-22-10.html#masterclass-22-10-ex-1b">Exercise 1b: Run a parallel tempering simulation</a>?</li>
<li>How much is the relative population of the two metastable states at T=300? Plot this population as a function of lambda (you can just extract results from the different replicas). Is there any relationship between the dependence on lambda and the dependence on T that we have seen in <a class="el" href="masterclass-22-10.html#masterclass-22-10-ex-1b">Exercise 1b: Run a parallel tempering simulation</a>?</li>
</ul>
<h2><a class="anchor" id="masterclass-22-10-ex-4"></a>
Exercise 4: Analyze Hamiltonian replica exchange simulations with WHAM</h2>
<p>So far we only analized the reference replica (lambda=1.0). We can however do better and combine all replicas with WHAM. To this aim you should:</p><ul>
<li>Concatenate all trajectories in a single file (<code>gmx_mpi trjcat -cat -f dir?/traj_comp.xtc dir??/traj_comp.xtc -o traj_multi.xtc</code>).</li>
<li>Recompute the potential energy according to each of the tpr files (for each replica) (<code>gmx_mpi mdrun -rerun traj_multi.xtc -s dir0/topol.tpr -e energy0.edr</code>, <code>gmx_mpi mdrun -rerun traj_multi.xtc -s dir1/topol.tpr -e ener1.edr</code>, etc.).</li>
<li>Convert the energies to text files (<code>echo 11 | gmx_mpi energy -f ener0.edr -xvg no -e energy0.xvg -xvg no</code>, etc.). 11 should select the potential energy.</li>
</ul>
<p>Then you can use the provided python wham script to compute the weight of all frames with the following python commands:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> wham</div>
<div class="line">print(wham.__file__) <span class="preprocessor"># make sure you are using the wham script provided with this masterclass</span></div>
<div class="line">energies=[]</div>
<div class="line">with cd(<span class="stringliteral">&quot;3/6reps&quot;</span>):</div>
<div class="line">    for i in range(len(lambdas)):</div>
<div class="line">        energies.append(np.loadtxt(<span class="stringliteral">&quot;energy{}.xvg&quot;</span>.format(i),usecols=1))</div>
<div class="line">energies=np.array(energies).T</div>
<div class="line"># energies[i,j] is the energy of frame i according to the j-th Hamiltonian</div>
<div class="line">kBT=0.00831446261815324*300</div>
<div class="line">w=wham.wham(energies,T=kBT)</div>
<div class="line"># w[<span class="stringliteral">&quot;logW&quot;</span>] are the Boltzmann factors</div>
<div class="line"># notice that we did not specify yet to which ensemble we are reweighting</div>
<div class="line"># this can be done with the following line:</div>
<div class="line">logW=w[<span class="stringliteral">&quot;logW&quot;</span>]-energies[:,0]/kBT</div>
<div class="line"># logW are the logaritm weights to obtain properties corresponding to replica 0</div>
<div class="line">logW-=np.max(logW) # avoid numerical errors in exp</div>
<div class="line">weights=np.exp(logW)</div>
<div class="line">weights/=np.sum(weights) # normalize weights</div>
<div class="line"># these weights can be used to compute weighted averages</div>
</div><!-- fragment --><p>Now plot the <code>weights</code> array and answer the following questions:</p><ul>
<li>How does the weight depend on the frame index? Remember that the replica exchange trajectories were concatenated. Can you recognize those frames coming from the first, second, etc replica?</li>
<li>Compute the population of the two states by summing the weight of all states in the two basins.</li>
<li>Modify the script above to compute weights corresponding to replicas other than the first one, and compute the population of the two states as a function of lambda.</li>
</ul>
<h2><a class="anchor" id="masterclass-22-10-ex-5"></a>
Exercise 5: Optimize the lambda ladder</h2>
<p>The aim of this exercise is to optimize the list of values of lambda. As a target, we will try to make the product of the acceptances as large as possible. We will do this <em>without</em> running new simulations, i.e. just analyzing the simulation above.</p>
<p>This is a difficult exercise. It will be solved in the solution, but it is <b>not</b> necessary to complete it so as to proceed to the next step. I write some hints here.</p><ul>
<li>In solute tempering, the energy is a quadratic function of <code>sqrt(lambda)</code>. In other words, for each frame, you could write the energy as <code>A*lambda+B*sqrt(lambda)+C</code>, where <code>A</code>, <code>B</code>, and <code>C</code> are to be recomputed at each frame. Analyze the <code>ene</code> array that we generated in the last exercise so as to obtain these coefficients. The goal is to have a function that, for any frame, and for any value of lambda (including values not yet simulated!), returns the energy of the system.</li>
<li>Using these functions, you will be able to compute weights corresponding to arbitrary values of lambda. You could for instance use these weights to generate a smooth version of the population vs lambda plot that we did in the last exercise.</li>
<li>Given two values of lambda, you can compute the average acceptance by doing ensemble averages. You can easily test this function: use it to predict the acceptance associated to the neighboring replicas simulated above. Can you predict the acceptances seen during the simulation?</li>
</ul>
<p>Once you have this function (let's call it <code>predict_acceptance(lambda1,lambda2)</code>) you can use the following script to find the ladder that maximizes the product of the acceptances. Let's say that the largest lambda is fixed to 1.0 and the lowest is fixed to <code>lambda_min</code></p>
<div class="fragment"><div class="line"><span class="preprocessor"># lambda is the array with the replicas we used for out simulation (a starting point(</span></div>
<div class="line"><span class="preprocessor"># first and last replicas are fixed (1.0 and lambda_min)</span></div>
<div class="line"><span class="preprocessor"># we thus optimize all elements excluding the first and the last (lambda[1:-1])</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># this function compute the acceptances given the three intermediate values of</span></div>
<div class="line"><span class="preprocessor"># lambda</span></div>
<div class="line">def predict_all_acceptances(x):</div>
<div class="line">    x=np.array(x)</div>
<div class="line">    acc=[]</div>
<div class="line">    # lambdas should not be negative</div>
<div class="line">    if np.any(x&lt;=0.0):</div>
<div class="line">        return np.zeros(len(x)+1)</div>
<div class="line">    # nor larger than 1</div>
<div class="line">    if np.any(x&gt;=1.0):</div>
<div class="line">        return np.zeros(len(x)+1)</div>
<div class="line">    # first replica has lambda=1.0</div>
<div class="line">    acc.append(predict_acceptance(1.0,x[0]))</div>
<div class="line">    for i in range(len(x)-1):</div>
<div class="line">        acc.append(predict_acceptance(x[i],x[i+1]))</div>
<div class="line">    # last replica has lambda=lambda_min</div>
<div class="line">    acc.append(predict_acceptance(x[-1],lambda_min))</div>
<div class="line">    return acc</div>
<div class="line"> </div>
<div class="line"># this is function to be minimized</div>
<div class="line">def func(x):</div>
<div class="line">    acc=predict_all_acceptances(x)</div>
<div class="line">    return -np.prod(acc) # negative, since we minimize the result</div>
<div class="line"> </div>
<div class="line">from scipy.optimize import minimize</div>
<div class="line">res=minimize(func,lambdas[1:-1]) # starting values</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;optimal lambdas: &quot;</span>,1.0,res.x,lambda_min)</div>
<div class="line">print(predict_all_acceptances(res.x))</div>
</div><!-- fragment --><p>You can then run a new simulation with the optimal lambdas and check if the predicted acceptances correspond to the observed ones!</p>
<h2><a class="anchor" id="masterclass-22-10-ex-6"></a>
Exercise 6: Combine with metadynamics on psi</h2>
<p>As a very last point, repeat exercise <a class="el" href="masterclass-21-5.html#masterclass-21-5-ex-5">Exercise 5: Parallel-tempering metadynamics</a> using alanine dipeptide in explicit solvent and solute tempering with the lambda values optimized above. No further guidance is provided for this exercise, but it should not be difficult following the suggestions given for <a class="el" href="masterclass-21-5.html#masterclass-21-5-ex-5">Exercise 5: Parallel-tempering metadynamics</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
<!--    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>  -->
    <li class="footer">   <!--- Generated by -->
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
